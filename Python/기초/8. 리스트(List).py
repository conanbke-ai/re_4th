# 리스트(List)

'''
1. 이터러블(Iterable) 자료형
    - 반복(iteration)이 가능한 객체의 총칭
        for 루프에 사용할 수 있는 모든 객체
    - 컬렉션(Collection) 및 제너레이터(Generator)
        - 제너레이터(Generator) : 값을 하나씩 생성하며 반복 가능한(iterable) 객체를 만드는 함수

2. 컬렉션(Collection) 자료형
    - 여러 개의 데이터를 하나의 변수에 묶어서 저장할 수 있는 자료형
        "데이터의 묶음"을 다룰 수 있는 자료형을 총칭하는 용어
    - in, not in 연산자를 통해 포함 여부 확인
    - 반복문(for)을 통한 순회 가능
    - len()으로 길이 확인 가능

    * 주요 컬렉션 자료형
        - list(리스트) : 순서 있음 / 중복 허용 / 가변   ex) [1, 2, 3]
        - tuple(튜플) : 순서 있음 / 중복 허용 / 불변    ex) (1, 2, 3)
        - set(집합) : 순서 없음 / 중복 불허 / 가변  ex) {1, 2, 3}
        - dict(딕셔너리) : 키-값 쌍 저장 / 중복 키 불허 / 순서 있음(3.7+)   ex){'a':1, 'b':2}

3. 시퀀스(Sequence) 자료형
    - 항목이 순서대로 정렬된 데이터의 묶음
        컬렉션의 하위 개념(컬렉션 중 순서가 있는 자료형)
        list, tuple은 시퀀스이자 컬렉션 / set, dict는 컬렉션이지만 시퀀스는 아님
    - 여러 개의 값을 순서대로 나열한 자료형
        순서(인덱스)가 존재함
    
        * 특징
            - 순서 존재
            - 인덱싱 : 특정 위치의 요소를 정수형 인덱스로 접근 가능
            - 슬라이싱 : 시퀀스의 일부분을 잘라서 새로운 시퀀스를 만들 수 있음
            - 반복 가능 : for문을 이용하여 각 요소를 순차적으로 순회(iterate)할 수 있음
        
        * 종류
            - str : 문자들의 시퀀스(문자열) / 불변
            - list : 요소들의 시퀀스, 다양한 자료형 가능 / 가변
            - tuple : 요소들의 시퀀스, 불변형 리스트 / 불변
            - range : 정수 시퀀스 생성 / 불변
'''

'''
리스트(List)
    여러 값들을 순서대로 저장할 수 있는 자료형
    인덱스로 각 항목에 접근할 수 있으며, 요소의 추가/삭제/수정이 자유로움
    
    * 특징
        - 순서 유지 : 요소가 입력된 순서대로 저장되고 유지됨
        - 중복 허용 : 동일한 값이 여러 개 존재할 수 있음
        - 다양한 자료형 저장 가능 : 정수, 실수, 문자열, 리스트 등 어떤 자료형도 저장 가능
        - 가변 객체(Mutable) : 요소의 추가, 삭제, 수정이 가능함
'''

# 사용 예제

# 빈 리스트
리스트이름1 = []

# 문자열만 저장
리스트이름2 = ["저장할 자료1", "저장할 자료2", "저장할 자료3"]

# 여러 자료형 저장
리스트이름3 = [10, "hello", 3.14, [1, 2, 3]]

'- 리스트는 대괄호 []로 표현됨'
'- 각 요소는 쉼표(,)로 구분'
'- 다양한 자료형 저장 가능'

# 빈 리스트
리스트이름1 = list()

# 문자열을 리스트로
문자열_리스트 = list("codingon")

print(리스트이름1)  # []
print(문자열_리스트)    # ['c', 'o', 'd', 'i', 'n', 'g', 'o', 'n']

# 문자열 "Hello"가 리스트로 변환되는 과정:
# "Hello" → ['H', 'e', 'l', 'l', 'o']

# 인덱스 구조 이해:
# H  e  l  l  o  ← 각 문자
# 0  1  2  3  4  ← 양수 인덱스 (앞에서부터 시작, 0부터)
# -5 -4 -3 -2 -1 ← 음수 인덱스 (뒤에서부터 시작, -1부터)

######################################################################################################
# 인덱싱(Indexing)

'''
시퀀스 자료형에서 특정 위치(인덱스) 값을 조회하는 것
    - 인덱스는 0부터 시작
    - 음수 인덱스 사용 시, 뒤에서부터 역순으로 접근 가능

    * 기본 문법
        시퀀스이름[인덱스]
'''

# ============================================
# 양수 인덱스를 사용한 요소 접근
# ============================================

print('인덱스 0: ', 문자열_리스트[0])  # 출력: 인덱스 0: c (첫 번째 요소)
print('인덱스 3: ', 문자열_리스트[3])  # 출력: 인덱스 3: i (네 번째 요소)
print('인덱스 4: ', 문자열_리스트[4])  # 출력: 인덱스 4: n (다섯 번째 요소)

# ============================================
# 음수 인덱스를 사용한 요소 접근
# ============================================

print('인덱스 -1: ', 문자열_리스트[-1])  # 출력: 인덱스 -1: n (마지막 요소)
print('인덱스 -3: ', 문자열_리스트[-3])  # 출력: 인덱스 -3: g (뒤에서 세 번째 요소)


# 사용 예제

text = "Python"
print(text[0])  # P
print(text[3])  # h
print(text[-1])  # h
print(text[-3])  # h

text[0] = "F"   # 에러발생 → 수정 불가

'- 문자열은 불변 자료형이므로 인덱스를 통한 수정은 불가능함'

fruits = ["apple", "banana", "cherry"]
print(fruits[0])    # apple
print(fruits[-1])   # cherry
fruits[1] = "orange"    # 인덱스를 통한 수정 가능
print(fruits)   # ["apple", "orange", "cherry"]

'- 리스트는 가변 자료형이므로 인덱스를 통한 수정이 가능함'

######################################################################################################
# 슬라이싱(Slicing)

'''
시퀀스에서 특정 구간을 잘라내어 부분적으로 추출하는 방법
    - 원본은 변경되지 않으며, 새로운 시퀀스를 생성함
    - start : 시작 인덱스(포함) / end : 끝 인덱스(불포함)
    - step : 간격(양수/음수 가능)

    * 기본 문법
        시퀀스[start:end]   # step 생략 가능
        시퀀스[start:end:step]
'''

# 사용 예제 - 문자열
text = "Python"
print(text[0:2])    # Py    (0 ~ 1)
print(text[:3])     # Pyt   (0 ~ 2)
print(text[3:])     # hon   (3 ~ 끝)
print(text[:])      # 전체복사
print(text[::-1])   # 문자열 뒤집기 / 처음부터 끝까지, 역방향으로 1칸씩 이동

print(text[::-2])   # nhy   처음부터 끝까지, 역방향으로 2칸씩 이동
print(text[:-4:-2])  # nh    끝에서 인덱스 -4 전까지, 역방향으로 2칸씩 이동

'- start 생략 시, 첫번째 요소부터 슬라이싱'
'- end 생략 시, 마지막 요소까지 슬라이싱'
'- start, end 모두 생략 시, 전체 문자열 복사'
'- step 에 -1 사용 시, 역순으로 전체 문자열 복사'

# 사용 예제 - 리스트
numbers = [10, 20, 30, 40, 50]
print(numbers[1:4])  # [20, 30, 40]
print(numbers[:3])  # [10, 20, 30]
print(numbers[::2])  # [10, 30, 50]
print(numbers[::-1])  # [50, 40, 30, 20, 10] 리스트 뒤집기

numbers = [1, 2, 3, 4, 5]
numbers[1:4] = [20, 30]  # 일부 구간을 다른 값으로 대체
print(numbers)  # [1, 20, 30, 5]


"""
주요 리스트 조작 기법 완전 정리:

1. 인덱싱 (단일 요소 접근):
   - 양수 인덱스: 앞에서부터 0, 1, 2, ... (첫 요소는 0)
   - 음수 인덱스: 뒤에서부터 -1, -2, -3, ... (마지막 요소는 -1)
   - 범위 초과 시 IndexError 발생

2. 슬라이싱 (여러 요소 접근):
   - 기본 문법: [시작:끝:스텝]
   - 끝 인덱스는 포함되지 않음 (미만의 개념)
   - 범위 초과 시 에러 없이 빈 리스트 또는 일부만 반환

3. 슬라이싱 주요 패턴:
   - [::-1]: 전체 뒤집기 (역순)
   - [::2]: 짝수 인덱스 (0, 2, 4, ...)
   - [1::2]: 홀수 인덱스 (1, 3, 5, ...)
   - [-n:]: 뒤에서 n개
   - [:n]: 앞에서 n개
   - [start:end]: 특정 범위

4. 요소 수정 방법:
   - 개별 수정: list[index] = new_value
   - 범위 수정: list[start:end] = new_list
   - 길이 변경 가능: 다른 길이의 리스트로 교체 가능

5. 실용적 응용:
   - 가운데 요소: list[len(list)//2]
   - 리스트 분할: 슬라이싱으로 구간별 처리
   - 조건부 추출: 스텝을 활용한 패턴 추출
   - 복합 연산: 슬라이싱 + 뒤집기 조합

6. 성능 고려사항:
   - 슬라이싱은 새로운 리스트 객체를 생성 (메모리 사용)
   - 큰 리스트에서는 메모리 효율성 고려 필요
   - 반복문보다 슬라이싱이 일반적으로 더 빠름

"""

"""
슬라이싱 기본 문법: [시작인덱스:끝인덱스:스텝]

1. 시작인덱스 (start):
   - 슬라이싱을 시작할 인덱스
   - 생략 시: 스텝이 양수면 처음(0)부터, 음수면 끝(-1)부터 시작

2. 끝인덱스 (stop):
   - 슬라이싱을 끝낼 인덱스 (해당 인덱스는 포함되지 않음!)
   - 생략 시: 스텝이 양수면 끝까지, 음수면 처음까지 진행

3. 스텝 (step):
   - 인덱스 증가/감소량 (기본값: 1)
   - 양수: 앞에서 뒤로 진행 (정방향)
   - 음수: 뒤에서 앞으로 진행 (역방향)

4. 요소 삭제:
   - del list[index]: 특정 인덱스의 요소 삭제
   - del list[start:end]: 범위 내 요소들 삭제
   - del list: 리스트 변수 자체를 삭제

5. 리스트 연산:
   - +: 연결 (concatenation) - 두 리스트를 하나로 합침
   - *: 반복 (repetition) - 리스트를 지정 횟수만큼 반복
   - in/not in: 멤버십 확인 - 특정 값의 존재 여부 확인
   
주요 슬라이싱 패턴:
- [:] → 전체 복사 (원본과 독립적인 새 객체)
- [::-1] → 전체 뒤집기 (역순)
- [::2] → 처음부터 2칸씩 건너뛰며 선택
- [1:4] → 인덱스 1부터 3까지 (4는 포함 안됨)
- [-3:] → 뒤에서 3번째부터 끝까지
- [:-2] → 처음부터 뒤에서 3번째까지 (뒤에서 2번째는 포함 안됨)

중요한 특징:
- 문자열: 불변객체(immutable)로 개별 문자 수정 불가
- 리스트: 가변객체(mutable)로 슬라이싱을 통한 여러 요소 동시 수정 가능
- 음수 인덱스: 뒤에서부터 세는 방식 (-1이 마지막 요소)
- 슬라이싱 결과: 항상 새로운 객체 생성 (원본은 변경되지 않음)
- 범위 초과: 인덱스가 범위를 벗어나도 에러가 발생하지 않음 (빈 결과 반환)
"""

######################################################################################################
# 실습 1 인덱싱, 슬라이싱 복습문제

'''
1. 첫번째 요소와 마지막요소 출력하기
    다음 리스트에서 첫번째 요소와 마지막요소를 출력하세요.
    nums = [10, 20, 30, 40, 50]
'''
# 리스트 선언
nums = [10, 20, 30, 40, 50]
# 양수 인덱스:  0   1   2   3   4
# 음수 인덱스: -5  -4  -3  -2  -1

# 리스트의 첫번째 요소와 마지막 요소 출력
print(nums[0], nums[-1])

# 10 50

'''
2. 가운데 세 개의 요소 추출하기
    다음 리스트에서 가운데 3개의 요소만 슬라이싱하여 새 리스트로 만들어 출력하세요.
    nums = [100, 200, 300, 400, 500, 600, 700]
'''

# 리스트 선언
nums = [100, 200, 300, 400, 500, 600, 700]
# 인덱스: 0    1    2    3    4    5    6
# 총 7개 요소 → 가운데 인덱스는 3 (7//2 = 3)

# 가운데 인덱스 계산
midIdx = len(nums)//2 - 1

# 가운데 3개 요소 출력
print(nums[midIdx: midIdx + 3])

# [300, 400, 500]

'''
3. 리스트의 원소 2배로 출력하기
    다음 리스트의 모든 요소를 2배하여 출력하세요.
    nums = [1, 2, 3, 4, 5]
'''

# 리스트 선언
nums = [1, 2, 3, 4, 5]
# 반복문
for i in range(0, len(nums)):   # 리스트 길이만큼 반복
    # 각 요소 값 2배 처리
    nums[i] *= 2

# 리스트 출력
print(nums)

# [2, 4, 6, 8, 10]

'''
4. 리스트 뒤집어서 출력하기
    다음 리스트를 역순으로 슬라이싱하여 출력하세요.
    items = ["a", "b", "c", "d", "e"]
'''

# 리스트 선언
items = ["a", "b", "c", "d", "e"]
# 역순으로 출력
print(items[::-1])

# ['e', 'd', 'c', 'b', 'a']

'''
5. 짝수 인덱스 요소만 출력하기
    다음 리스트에서 짝수 인덱스(0, 2, 4 ...)의 요소들만 출력하세요.
    data = ["zero", "one", "two", "three", "four", "five"]
'''

# 리스트 선언
data = ["zero", "one", "two", "three", "four", "five"]
# 짝수 인덱스만 출력
print(data[::2])

# ['zero', 'two', 'four']


'''
6. 슬라이싱으로 리스트 수정하기
    다음 리스트에서 "어벤져스", "라라랜드"를 "매트릭스", "타이타닉"으로 수정하세요.
    movies = ["인셉션", "인터스텔라", "어벤져스", "라라랜드", "기생충"]
'''

# 리스트 선언
movies = ["인셉션", "인터스텔라", "어벤져스", "라라랜드", "기생충"]
# 리스트 수정
movies[2:4] = ["매트릭스", "타이타닉"]
# 리스트 출력
print(movies)

# '인셉션', '인터스텔라', '매트릭스', '타이타닉', '기생충']

'''
7. 특정 규칙에 따라 요소 추출
    다음 리스트에서 "물리", "생물", "지구과학"만 순서대로 추출하여 새 리스트로 출력하세요.
    subjects = ["국어", "수학", "영어", "물리", "화학", "생물", "역사", "지구과학", "윤리"]
'''

# 리스트 선언
subjects = ["국어", "수학", "영어", "물리", "화학", "생물", "역사", "지구과학", "윤리"]
# "물리", "생물", "지구과학" 순서대로 추출
print(subjects[3::2])

# ['물리', '생물', '지구과학']

'''
8. 리스트를 3개 구간으로 나누어 역순으로 병합
    다음 리스트에서 [1~3번째 요소] + [4~6번째 요소] + [7~9번째 요소] 순서로 3개의 구간으로 나눈 뒤,
        각 구간을 역순으로 따로 출력하세요.
        단, 출력 시 한 줄로 출력하세요.
    data = ["A","B","C","D","E","F","G","H","I",]
'''

# 리스트 선언
data = ["A", "B", "C", "D", "E", "F", "G", "H", "I"]
# 구간 나누기
data1 = data[:3]
data2 = data[3:6]
data3 = data[6:]
# 각 구간 역순으로 출력
print(data1[::-1], data2[::-1], data3[::-1])

# ['C', 'B', 'A'] ['F', 'E', 'D'] ['I', 'H', 'G']

# ============================
# 에단 리더 답변
# ============================

data = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']
# 인덱스: 0    1    2    3    4    5    6    7    8
# 총 9개 요소를 3개씩 나누어 각 구간을 역순으로 처리

# 첫 번째 구간: 인덱스 0~2 (3개 요소)
part1 = data[0:3][::-1]   # data[0:3] → ['A','B','C'] → 뒤집기 → ['C','B','A']
# 두 번째 구간: 인덱스 3~5 (3개 요소)
part2 = data[3:6][::-1]   # data[3:6] → ['D','E','F'] → 뒤집기 → ['F','E','D']
# 세 번째 구간: 인덱스 6~8 (3개 요소)
part3 = data[6:9][::-1]   # data[6:9] → ['G','H','I'] → 뒤집기 → ['I','H','G']

print('3구간 역순 결과:', part1, part2, part3, sep=' ')
# 출력: 3구간 역순 결과: ['C', 'B', 'A'] ['F', 'E', 'D'] ['I', 'H', 'G']
print()


######################################################################################################
# 리스트 요소 삭제 -del

'''
파이썬 내장 키워드로 객체를 삭제(delete) 하는 데 사용
    del : 범용 삭제 키워드 : 리스트의 요소 뿐 아니라, 변수 자체, 딕셔너리의 키, 객체 속성 등도 삭제 가능

    * 기본 문법
        del 리스트[인덱스]      # 특정 요소 1개 삭제
        del 리스트[ster:end]    # 슬라이싱 범위 삭제
        del 리스트              # 리스트 전체 객체 삭제
'''

# 사용 예제 - 슬라이싱 범위 삭제
fruits = ["apple", "banana", "cherry", "date"]
del fruits[1:3]
print(fruits)   # ['apple', 'date']

# 사용 예제 - 전체 리스트 객체 삭제
my_list = [1, 2, 3]
del my_list
print(my_list)  # NameError: name 'my_list' is not defined

# 사용 예제 - 스텝을 활용한 삭제
data = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print('삭제 전 data:', data)

# 짝수 인덱스 요소들을 뒤에서부터 삭제 (인덱스 변경 방지)
# 인덱스 8, 6, 4, 2, 0 순서로 삭제
for i in [8, 6, 4, 2, 0]:  # 역순으로 삭제
    del data[i]

print('짝수 인덱스 삭제 후:', data)  # 짝수 인덱스 삭제 후: [1, 3, 5, 7, 9]

# 사용 예제 - 리스트 활용 삭제
list1 = [10, 20, 30, 40, 50]
# 인덱스: 0   1   2   3   4

# del을 사용하여 특정 인덱스의 요소 삭제
del list1[3]  # 인덱스 3의 요소 40을 삭제
print(list1)  # 출력: [10, 20, 30, 50] (삭제 후 뒤 요소들이 앞으로 이동)

# del을 사용하여 슬라이싱 범위의 요소들 삭제
del list1[1:3]  # 인덱스 1,2의 요소들 [20, 30]을 삭제
print(list1)  # 출력: [10, 50]

# 주의사항: del list1을 실행하면 리스트 변수 자체가 메모리에서 삭제됨
# del list1  # 실행하면 이후에 list1에 접근할 때 NameError 발생
# print(list1)  # NameError: name 'list1' is not defined

print()  # 빈 줄 출력

"""
del을 사용한 리스트 요소 삭제 완전 가이드:

1. 기본 문법:
   - del list[index]: 특정 인덱스 삭제
   - del list[start:end]: 범위 삭제 (start 이상 end 미만)
   - del list[start:end:step]: 스텝 간격으로 삭제

2. 삭제 후 인덱스 변화:
   - 요소 삭제 후 뒤의 모든 요소들이 앞으로 이동
   - 리스트의 길이가 감소
   - 기존 인덱스 번호가 무효화될 수 있음

3. 안전한 삭제 방법:
   - 여러 요소 삭제 시 뒤에서부터 삭제 (큰 인덱스부터)
   - 또는 삭제할 요소들을 별도로 수집 후 일괄 삭제
   - 반복문에서 삭제 시 역순으로 진행

4. del의 다양한 활용:
   - del variable: 변수 자체를 메모리에서 삭제
   - del list[:]: 리스트의 모든 요소 삭제 (빈 리스트 만들기)
   - del list[::2]: 짝수 인덱스 요소들 삭제

5. 대안 방법들:
   - list.remove(value): 값으로 삭제 (첫 번째 발견 요소만)
   - list.pop(index): 삭제하면서 반환값 받기
   - list.clear(): 모든 요소 삭제

6. 성능 고려사항:
   - 앞쪽 요소 삭제는 느림 (모든 뒤 요소들이 이동)
   - 뒤쪽 요소 삭제는 빠름
   - 대량 삭제 시에는 새 리스트 생성이 더 효율적일 수 있음

주의: 존재하지 않는 인덱스 삭제 시 IndexError 발생
"""

######################################################################################################
# 리스트 연산

'''
1. 리스트 연결(+)
    + 연산자로 두 리스트를 이어붙여 하나의 새로운 리스트 생성
        원본 리스트는 변경되지 않고, 새로운 리스트 객체가 만들어짐
    
    * 기본 문법
        리스트 + 리스트
'''

# 사용 예제
a = [1, 2, 3]
b = [4, 5, 6]
c = a + b
print(c)    # [1, 2, 3, 4, 5, 6]

'- 연산 결과 새로운 리스트 반환'

'''
2. 리스트 반복(*)
    * 연산자로 지정한 횟수만큼 반복하여 새로운 리스트를 생성
        원본 리스트는 변경되지 않고, 새로운 리스트 객체가 만들어짐
        반복된 리스트의 요소들은 원래 순서를 유지함
        
    * 기본 문법
        리스트 * 정수
'''

# 사용 예제
a = [1, 2, 3]
b = a * 3
print(b)    # [1, 2, 3, 1, 2, 3, 1, 2, 3]

'- 반복하는 배열의 요소들의 순서는 변하지 않음'
'- 연산 결과 새로운 리스트 반환'

'''
3. 포함 여부 검사(in / not in)
    특정 요소가 리스트에 존재하는 지 확인
'''

# 사용 예제
fruits = ["apple", "banana", "cherry"]
print("apple" in fruits)    # True ("apple" 이 fruit 리스트에 있음)
print("grape" not in fruits)    # True ("grape"이 fruit 리스트에 없음)


######################################################################################################
# 실습 2 리스트 연산 복습문제

'''
1. 부분 삭제 후 연결
    다음 리스트 가운데 3개 요소 ("banana", "cherry", "grape")를 삭제한 뒤,
    나머지 앞/뒤 리스트를 연결하여 새 리스트 result를 출력하세요.

    fruits = ["apple", "banana", "cherry", "grape", "watermelon", "strawberry"]
'''

# 리스트 선언
fruits = ["apple", "banana", "cherry", "grape", "watermelon", "strawberry"]

# 가운데 인덱스
minIdx = len(fruits)//2 - 1

# 가운데 3개 요소 삭제
del fruits[minIdx: minIdx + 3]

# 리스트 출력
print(fruits)

# ['apple', 'watermelon', 'cherry']

'''
2. 반복 리스트 내부 요소 삭제
    다음 리스트를 3번 반복한 후, 전체 결과에서 중간에 있는 "A"만 삭제하세요.

    letters = ["A", "B"]
'''

# 리스트 선언
letters = ["A", "B"]

# 리스트 3번 반복
letters *= 3

# 가운데 인덱스 계산
midIdx = len(letters)//2 - 1

# letters 길이만큼 반복
for i in range(0, len(letters)):
    # 요소 값이 "A"인 경우
    if letters[i] == "A":
        # 요소 인덱스가 가운데 값인 경우
        if i == midIdx:
            # 해당 요소 삭제
            del letters[midIdx]
            # 반복 종료
            break

# 리스트 출력
print(letters)  # ['A', 'B', 'B', 'A', 'B']

######################################################################################################
# 주요 메서드

'''
1. len() 함수 : 길이(요소 개수) 제한
    시퀀스나 컬렉션 자료형의 요소 개수 반환 
'''

# 사용 예제
numbers = [10, 20, 30, 40]
print(len(numbers))  # 4

text = "Hello"
print(len(text))    # 5

'''
2. append(x) 함수 : 리스트 끝에 요소 추가
    리스트 마지막에 하나의 요소를 추가함
    전달받은 객체를 하나의 요소로 추가 (객체 자체가 추가됨)
'''

# 사용 예제
fruits = ["apple", "banana"]
fruits.append("cherry")
print(fruits)   # ['apple', 'banana', 'cherry']

fruits.append([1, 2, 3])    # 리스트 [1, 2, 3] 전체가 하나의 요소로 추가
print(fruits)   # ['apple', 'banana', 'cherry', [1, 2, 3]]

'''
3. extend(iterable) : 리스트 끝에 여러 요소 추가
    다른 리스트나 이터러블의 모든 요소를 추가함
    반복 가능한 객체의 각 요소들을 개별적으로 추가
'''

# 사용 예제
fruits = ["apple", "banana"]
fruits.extend(["cherry", "date"])
print(fruits)   # ['apple', 'banana', 'cherry', 'date]

'''
4. insert(index, x) : 원하는 위치에 요소 삽입
    지정한 인덱스에 요소 삽입
'''

# 사용 예제
numbers = [1, 2, 4]
numbers.insert(2, 3)    # 2번 인덱스에 3 삽입, 기존 요소들은 뒤로 밀림
print(numbers)  # [1, 2, 3, 4]

'''
5. remove(x) : 특정 값을 찾아 삭제
    가장 처음 발견된 해당 값(x) 삭제
'''

# 사용 예제
numbers = [1, 2, 3, 2, 4]
numbers.remove(2)   # 첫 번째 2만 제거됨 (두 번째 2는 남아있음)
print(numbers)  # [1, 3, 2, 4]

'''
6. pop(index) : 인덱스 요소를 꺼내고 삭제
    인덱스를 지정하면 해당하는 인덱스의 요소를 삭제하고 반환함
    인덱스를 지정하지 않으면 마지막 요소를 삭제하고 반환함
'''

# 사용 예제
numbers = [10, 20, 30]
print(numbers.pop())  # 30
print(numbers)  # [10, 20]

print(numbers.pop(0))   # 10
print(numbers)  # [20]

'''
7. 리스트 정렬 : sort(), sorted()
    list.sort() : 원본 리스트 정렬
    sorted(list) : 정렬된 새로운 리스트 반환

    - 기본 : 오름차순 정렬 / reverse = True 옵션 시 내림차순 정렬
'''

# 사용 예제
# sort() / 원본 변경
numbers = [3, 1, 2]
numbers.sort()  # 오름차순 정렬
print(numbers)  # [1, 2, 3]
numbers.sort(reverse=True)  # 내림차순 정렬
print(numbers)  # [3, 2, 1]

# sorted() / 원본 변경하지 않고 정렬된 새 리스트 반환
scores = [88, 95, 70]
sorted_scores = sorted(scores)  # 오름차순 정렬
sorted_scores_r = sorted(scores, reverse=True)  # 내림차순 정렬
print(sorted_scores)    # [70, 88, 95]
print(sorted_scores_r)  # [95, 88, 70]
print(scores)           # [88, 95, 70]

'''
8. 요소 검색 : index()
    지정된 값의 첫 번째 인덱스 반환
'''

# 사용 예제
idx = numbers.index(6)  # 값 6이 처음 나타나는 인덱스를 찾기
print('idx: ', idx)  # idx: 2 (인덱스 2에 6이 있음)

idx = numbers.index(9)  # 값 9가 처음 나타나는 인덱스를 찾기
print('idx: ', idx)  # idx: 3 (인덱스 3에 9가 있음)


'''
8. reverse() : 리스트 요소 뒤집기
    리스트 자체를 뒤집음(원본 변경)
'''

# 사용 예제
numbers = [1, 2, 3]
numbers.reverse()
print(numbers)  # [3, 2, 1]


'''
9. count(x) : 값의 개수 세기
    값(x)의 개수를 세서 반환
'''

# 사용 예제
numbers = [1, 2, 2, 3, 2]
print(numbers.count(2))  # 3


'''
10. max(x), min() : 최대/최소값 찾기
'''

# 사용 예제
scores = [88, 95, 70, 100, 65]
print(max(scores))  # 100
print(min(scores))  # 65


'''
11. sum() : 요소들의 합 구하기
'''

# 사용 예제
scores = [88, 95, 70]
print(sum(scores))  # 253


"""
리스트 메서드와 함수의 차이점:
1. 메서드 (append, extend, remove, pop, clear, sort 등):
   - 리스트 객체에 직접 적용됨 (list.method())
   - 대부분 원본 리스트를 직접 수정함
   - 반환값이 None인 경우가 많음

2. 함수 (sorted, max, min, sum 등):
   - 리스트를 매개변수로 받음 (function(list))
   - 원본 리스트를 변경하지 않음
   - 결과값을 반환함

주요 활용 팁:
- 원본 리스트를 보존하고 싶다면 sorted() 함수 사용
- 메모리 효율성을 위해 원본을 직접 수정해도 된다면 sort() 메서드 사용
- remove()는 첫 번째 일치하는 요소만 제거하므로 주의
- pop()은 제거와 동시에 값을 반환하므로 제거된 값이 필요할 때 유용
"""

######################################################################################################
# 실습 3 리스트 주요 메서드 복습 문제

'''
1. 기차 탑승 시뮬레이션
    기차에 승객들이 순서대로 탑승하고 있습니다.
        1. 처음엔 ["철수", "영희"]가 탑승했습니다.
        2. 그 다음 역에서 ["민수", "지훈"]이 함께 탑승했습니다.
        3. 다음 역에서 "영희"는 내렸습니다.
        4. "수진"이 1번 자리에 끼어 탑승했습니다.
        5. 마지막 역에서 "민수"가 내렸고, 기차 안의 순서를 뒤집었습니다.
    현재 기차 안에는 어떤 승객들이 어떤 순서로 앉아 있을까요?
'''

# 리스트 선언
customer_list = []

print("1. 첫 번째 역입니다. 철수와 영희가 탑승하였습니다.")
customer_list.extend(["철수", "영희"])

print("2. 두 번째 역입니다. 민수와 지훈이 탑승하였습니다.")
customer_list.extend(["민수", "지훈"])

print("3. 세 번째 역입니다. 영희가 하차하였습니다.")
customer_list.remove("영희")

print("4. 네 번째 역입니다. 수진이 1번 자리에 탑승하였습니다.")
customer_list.insert(0, "수진")

print("5. 다섯 번째 역입니다. 민수가 하차하였습니다.")
customer_list.remove("민수")

print("6. 기차 안의 순서가 뒤집어졌습니다.")
customer_list.reverse()

print("최종 승객 리스트 : ", customer_list)

# 1. 첫 번째 역입니다. 철수와 영희가 탑승하였습니다.
# 2. 두 번째 역입니다. 민수와 지훈이 탑승하였습니다.
# 3. 세 번째 역입니다. 영희가 하차하였습니다.
# 4. 네 번째 역입니다. 수진이 1번 자리에 탑승하였습니다.
# 5. 다섯 번째 역입니다. 민수가 하차하였습니다.
# 6. 기차 안의 순서가 뒤집어졌습니다.
# 승객 리스트 :  ['지훈', '철수', '수진']

'''
2. 숫자 처리 게임
    숫자 카드 게임에서 다음 리스트가 주어졌습니다. [5, 3, 7]
        1. 2장을 더 추가해서 [4, 9]가 들어옵니다.
        2. 가장 큰 수와 가장 작은 수를 각각 구해 출력하세요.
        3. 총 합을 출력하세요.
        4. 리스트를 정렬한 다음, 마지막 숫자를 제거하세요.
        5. 최종 리스트를 출력하세요.
'''

# 리스트 선언
numbers = [5, 3, 7]
# 리스트 추가
numbers.extend([4, 9])

# 리스트 출력
print("가장 큰 수 : ", max(numbers), ", 가장 작은 수 : ", min(numbers))
print("총 합 : ", sum(numbers))

# 리스트 정렬
numbers.sort()
# 리스트의 마지막 요소 제거
numbers.pop()

# 리스트 출력
print(numbers)

# 가장 큰 수 :  9 , 가장 작은 수 :  3
# 총 합 :  28
# [3, 4, 5, 7]
